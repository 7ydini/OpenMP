#include<omp.h>
#include <string>
#include <iostream>
#include <ctime>
#include<algorithm> 
using namespace std;
//int fun1(int* A, int* B, int i, int t);
//int fun2(int* A, int* B, int i, int t);
int main()
{
	setlocale(LC_ALL, "Russian");
	srand(time(NULL));
	int j, i;
	int N;
	cout << "Кол-во элементов массивов A и B >>>";
	cin >> N;
	double time = omp_get_wtime();
	int* a = new int[N];//объявление динамического массива
	int* b = new int[N];
#pragma omp parallel private(i)
	{
#pragma omp for			
	for (int i = 0; i < N; i++)//Заполнение случайными числами
	{
		a[i] = rand() % 1000;
	}

#pragma omp for	//First section	
	for (int i = 0; i < N; i++)
	{
		b[i] = rand() % 1000;
	}
	}
		
	int total = 0, total2 = 0, sum = 0, s;
#pragma omp sections private(sum)
	{		
#pragma omp section		//First section	
		{
	for (int j = 0; j < N; j++)
			{
				sum = a[j] + b[j];
				if (sum > 1 && total < sum)
				{
					total = sum;
				}
			}
		}
#pragma omp section		//Second section
		{
			for (int j = 0; j < N; j++)
			{
				sum = 4 * a[j] - b[j];
				if (sum > 1 && total2 < sum)
				{
					total2 = sum;
				}
			}
		}
	}
	if (total > total2)
	{
		cout << "Сумма значений MAX(A[i] + B[i],4*A[i] - B[i]) равна>>" << total << "\n";
	}
	else
	{
		cout << "Сумма значений MAX(A[i] + B[i],4*A[i] - B[i]) равна>>" << total2 << "\n";
	}

	double end = omp_get_wtime();
	cout << omp_get_wtime() - time << endl;
}
//При создании массивов на 100 000 000 элементов 
//Используя параллеливание выходит 1.14, а без 5.44, что в 5 раз быстрее.
